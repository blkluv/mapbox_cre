<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ATLWarehouse Grid</title>

  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet"/>

  <style>
    body { margin:0; padding:0; background:#0a0a0a; font-family:Arial, sans-serif; }
    #map { position:absolute; top:64px; bottom:0; width:100%; }

    #header {
      position:fixed; top:0; left:0; right:0; height:64px;
      background: linear-gradient(90deg, #00ffea, #ff00ff);
      display:flex; align-items:center; justify-content:center; gap:12px;
      z-index:1000; padding:0 10px; flex-wrap:wrap;
    }
    #header a {
      display:flex; align-items:center; gap:8px;
      color:#000; text-decoration:none; background:#fff;
      padding:8px 12px; border-radius:10px; font-weight:700; font-size:14px;
      box-shadow: 0 8px 24px rgba(0,0,0,.25);
    }

    #panel {
      position:absolute; top:74px; left:10px; z-index:1000;
      background: rgba(10,10,10,.92);
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px; padding:12px; width: 300px; max-width: calc(100vw - 20px);
      color:#fff; box-shadow: 0 12px 40px rgba(0,0,0,.45);
    }
    #panel h3 { margin:0 0 8px; font-size:14px; color:#00ffea; }
    .row { display:flex; gap:10px; margin:10px 0; flex-wrap:wrap; }
    .btn {
      cursor:pointer; border:none; border-radius:10px;
      padding:10px 10px; font-weight:800;
      background:#00ffea; color:#000; flex:1;
    }
    .btn.secondary { background:#222; color:#fff; border:1px solid rgba(255,255,255,.12); }
    .toggle { display:flex; align-items:center; justify-content:space-between; gap:10px; margin:8px 0; }
    .toggle label { font-size:13px; color:#ddd; }
    input[type="checkbox"] { transform: scale(1.1); }

    .mapboxgl-popup-content{
      background: rgba(0,0,0,.9) !important;
      color:#fff; border-radius:14px; border:1px solid rgba(255,255,255,.10);
      box-shadow: 0 16px 60px rgba(0,0,0,.55);
      padding:12px 12px 10px;
      max-width: 340px !important;
    }
    .popup-title { margin:0 0 6px; font-size:16px; color:#00ffea; }
    .badge {
      display:inline-flex; align-items:center; gap:6px;
      padding:4px 8px; border-radius:999px; font-size:12px; font-weight:800;
      border: 1px solid rgba(255,255,255,.14);
    }
    .badge.verified { background: rgba(0,255,234,.15); color:#00ffea; }
    .badge.public { background: rgba(255,255,255,.08); color:#ddd; }
    .badge.inspected { background: rgba(255,0,255,.15); color:#ff7cff; }

    .kv { font-size:13px; color:#ddd; margin:6px 0; line-height:1.35; }
    .kv strong { color:#fff; }
    .actions { display:flex; gap:10px; margin-top:10px; flex-wrap:wrap; }
    .action {
      flex:1;
      background:#00ffea; color:#000; border:none; border-radius:12px;
      padding:10px 10px; font-weight:900; cursor:pointer;
    }
    .action.secondary {
      background:#222; color:#fff; border:1px solid rgba(255,255,255,.12);
    }

    .legend {
      margin-top:10px; font-size:12px; color:#aaa;
      border-top:1px solid rgba(255,255,255,.10); padding-top:10px;
    }
    .legend .dot { display:inline-block; width:10px; height:10px; border-radius:50%; margin-right:6px; }
  </style>
</head>
<body>

  <div id="header">
    <a href="https://ops.atlwarehouse.com">‚öôÔ∏è OPS</a>
    <a href="https://atlwarehouse.com">üè† HOME</a>
    <a href="https://tiktok.com/@atlwarehouse">üéµ TIKTOK</a>
    <a href="https://tv.atlwarehouse.com">üì∫ TV</a>
  </div>

  <div id="panel">
    <h3>ATLWarehouse Grid ‚Äî Phase 1</h3>

    <div class="toggle">
      <label>Show Submarket Boundaries</label>
      <input id="toggle-submarkets" type="checkbox" checked />
    </div>

    <div class="toggle">
      <label>Show Labor Heatmap</label>
      <input id="toggle-heatmap" type="checkbox" checked />
    </div>

    <div class="toggle">
      <label>Show Verified Only</label>
      <input id="toggle-verified" type="checkbox" />
    </div>

    <div class="toggle">
      <label>Capacity Available (&lt; 75% utilized)</label>
      <input id="toggle-capacity" type="checkbox" />
    </div>

    <div class="row">
      <button class="btn" id="btn-atl">üìç ATLANTA</button>
      <button class="btn secondary" id="btn-fit">üß≠ FIT</button>
    </div>

    <div class="legend">
      <div><span class="dot" style="background:#00ffea"></span>Public Shell</div>
      <div><span class="dot" style="background:#ff7cff"></span>Inspected</div>
      <div><span class="dot" style="background:#ffd000"></span>Verified</div>
    </div>
  </div>

  <div id="map"></div>

<script>
  // =========================
  // CONFIG
  // =========================
  mapboxgl.accessToken = "YOUR_MAPBOX_TOKEN";

  const ATL_CENTER = [-84.39, 33.77];
  const ATL_ZOOM = 10;

  // Phase 1 warehouse source:
  // In production: serve from your backend as /api/facilities.geojson (Phase 2)
  // For now: we fetch from Overpass (public OSM) and convert -> GeoJSON.
  const OVERPASS_ENDPOINT = "https://overpass-api.de/api/interpreter";

  // =========================
  // MAP INIT
  // =========================
  const map = new mapboxgl.Map({
    container: "map",
    style: "mapbox://styles/mapbox/dark-v11",
    center: ATL_CENTER,
    zoom: ATL_ZOOM
  });
  map.addControl(new mapboxgl.NavigationControl());

  // =========================
  // DATA: SUBMARKETS (SAMPLE)
  // Replace these polygons with your real ATL industrial submarket GeoJSON later.
  // =========================
  const submarketsGeoJSON = {
    "type":"FeatureCollection",
    "features":[
      {
        "type":"Feature",
        "properties":{"name":"Airport Corridor"},
        "geometry":{"type":"Polygon","coordinates":[[
          [-84.52,33.62],[-84.34,33.62],[-84.34,33.70],[-84.52,33.70],[-84.52,33.62]
        ]]}
      },
      {
        "type":"Feature",
        "properties":{"name":"Camp Creek"},
        "geometry":{"type":"Polygon","coordinates":[[
          [-84.62,33.62],[-84.50,33.62],[-84.50,33.68],[-84.62,33.68],[-84.62,33.62]
        ]]}
      },
      {
        "type":"Feature",
        "properties":{"name":"South Fulton"},
        "geometry":{"type":"Polygon","coordinates":[[
          [-84.70,33.55],[-84.48,33.55],[-84.48,33.62],[-84.70,33.62],[-84.70,33.55]
        ]]}
      }
    ]
  };

  // =========================
  // HELPERS
  // =========================
  function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }

  // Simple ‚Äúlabor index‚Äù placeholder:
  // In Phase 2 you‚Äôll compute this from wage/commute/job density datasets.
  function laborIndexFromLatLng(lat, lng){
    // Creates some variation so heatmap is meaningful. Replace later.
    const base = 0.5 + 0.5*Math.sin((lat-33.7)*12) * Math.cos((lng+84.4)*10);
    return clamp(base, 0, 1);
  }

  // =========================
  // OVERPASS -> GEOJSON (PUBLIC WAREHOUSE SHELLS)
  // =========================
  async function fetchWarehousesFromOSM(){
    // Bounding box around Atlanta metro industrial core (tune as needed)
    const query = `
      [out:json][timeout:25];
      (
        node["building"="warehouse"](33.45,-84.75,34.05,-84.05);
        way["building"="warehouse"](33.45,-84.75,34.05,-84.05);
      );
      out center tags;
    `;

    const res = await fetch(OVERPASS_ENDPOINT, { method:"POST", body: query });
    const data = await res.json();

    const features = [];
    for(const el of data.elements){
      let lon, lat;
      if(el.type === "node"){ lon = el.lon; lat = el.lat; }
      else if(el.type === "way" && el.center){ lon = el.center.lon; lat = el.center.lat; }
      else continue;

      const name = (el.tags && el.tags.name) ? el.tags.name : "Warehouse Facility";

      // Phase 1 public shell defaults:
      // verified/inspected/capacity/etc will come from Phase 2 backend later.
      const labor = laborIndexFromLatLng(lat, lon);

      features.push({
        type: "Feature",
        properties: {
          id: `${el.type}-${el.id}`,
          name,
          source: "OSM",
          // status flags (Phase 1 defaults)
          verified: 0,
          inspected: 0,
          utilization: null, // unknown in public data
          grade: null,
          labor_index: labor
        },
        geometry: { type:"Point", coordinates:[lon, lat] }
      });
    }

    return { type:"FeatureCollection", features };
  }

  // =========================
  // PHASE 2 HOOK:
  // If you have backend, replace the above with:
  // const geo = await fetch("/api/facilities.geojson").then(r=>r.json());
  // =========================

  // =========================
  // UI FILTERS
  // =========================
  const ui = {
    submarkets: document.getElementById("toggle-submarkets"),
    heatmap: document.getElementById("toggle-heatmap"),
    verified: document.getElementById("toggle-verified"),
    capacity: document.getElementById("toggle-capacity"),
    btnATL: document.getElementById("btn-atl"),
    btnFit: document.getElementById("btn-fit"),
  };

  function setLayerVisibility(layerId, visible){
    if(!map.getLayer(layerId)) return;
    map.setLayoutProperty(layerId, "visibility", visible ? "visible" : "none");
  }

  function applyFilters(){
    // Filter expression for point layer (unclustered points only).
    // We use separate cluster layers for clusters (those should remain).
    const filters = ["all"];

    if(ui.verified.checked){
      filters.push(["==", ["get","verified"], 1]);
    }

    if(ui.capacity.checked){
      // show only if utilization is known and < 0.75
      filters.push(["all",
        ["!=", ["get","utilization"], null],
        ["<", ["get","utilization"], 0.75]
      ]);
    }

    // Apply to unclustered circle layer (points).
    if(map.getLayer("unclustered-points")){
      map.setFilter("unclustered-points", ["all", ["!", ["has","point_count"]], ...filters.slice(1)]);
    }

    // Heatmap respects verified toggle optionally:
    if(map.getLayer("labor-heat")){
      const heatFilter = ["all"];
      if(ui.verified.checked) heatFilter.push(["==", ["get","verified"], 1]);
      map.setFilter("labor-heat", heatFilter);
    }
  }

  // =========================
  // POPUP + ACTIONS (Phase 2/3 hooks)
  // =========================
  function popupHTML(p){
    const badges = [];
    if(p.verified === 1) badges.push(`<span class="badge verified">‚úÖ Verified</span>`);
    else badges.push(`<span class="badge public">üåê Public Shell</span>`);
    if(p.inspected === 1) badges.push(`<span class="badge inspected">üé• Inspected</span>`);

    const util = (p.utilization === null || p.utilization === undefined)
      ? "Unknown"
      : `${Math.round(p.utilization*100)}%`;

    const grade = p.grade ? p.grade : "Not Graded";

    return `
      <div>
        <h3 class="popup-title">${p.name}</h3>
        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-bottom:8px;">
          ${badges.join("")}
        </div>

        <div class="kv"><strong>üìç Region:</strong> Atlanta Industrial</div>
        <div class="kv"><strong>üìä Utilization:</strong> ${util}</div>
        <div class="kv"><strong>üè∑ Grade:</strong> ${grade}</div>
        <div class="kv"><strong>üë∑ Labor Index:</strong> ${Math.round((p.labor_index||0)*100)}/100</div>

        <div class="actions">
          <button class="action" onclick="requestInfo('${p.id}')">Request Info</button>
          <button class="action secondary" onclick="claimFacility('${p.id}')">Claim</button>
          <button class="action secondary" onclick="compare3PL('${p.id}')">Compare 3PL</button>
        </div>

        <div style="margin-top:8px; font-size:12px; color:#9aa;">
          Source: ${p.source || "Unknown"} ¬∑ ID: ${p.id}
        </div>
      </div>
    `;
  }

  // Phase 2/3 stubs (these will call your backend once installed)
  window.requestInfo = (id) => {
    // Hook this to your Fluent Form or CRM endpoint
    alert(`Request Info ‚Üí ${id}\nNext: post to your OPS form / CRM.`);
  };

  window.claimFacility = async (id) => {
    // Phase 2: POST /api/claim
    alert(`Claim flow stub ‚Üí ${id}\nPhase 2 backend required.`);
  };

  window.compare3PL = async (id) => {
    // Phase 3: GET /api/compare?facilityId=...
    alert(`3PL comparison stub ‚Üí ${id}\nPhase 3 backend required.`);
  };

  // =========================
  // LOAD + RENDER
  // =========================
  map.on("load", async () => {

    // --- Submarkets source/layers
    map.addSource("submarkets", { type:"geojson", data: submarketsGeoJSON });

    map.addLayer({
      id:"submarket-fill",
      type:"fill",
      source:"submarkets",
      paint:{
        "fill-color":"#00ffea",
        "fill-opacity":0.08
      }
    });

    map.addLayer({
      id:"submarket-outline",
      type:"line",
      source:"submarkets",
      paint:{
        "line-color":"#00ffea",
        "line-width":1.2,
        "line-opacity":0.7
      }
    });

    map.addLayer({
      id:"submarket-label",
      type:"symbol",
      source:"submarkets",
      layout:{
        "text-field":["get","name"],
        "text-size":12
      },
      paint:{
        "text-color":"#ffffff",
        "text-halo-color":"#000000",
        "text-halo-width":1.2
      }
    });

    // --- Fetch warehouses
    const warehouseGeo = await fetchWarehousesFromOSM();

    // Source with clustering
    map.addSource("warehouses", {
      type: "geojson",
      data: warehouseGeo,
      cluster: true,
      clusterMaxZoom: 13,
      clusterRadius: 50
    });

    // --- Labor heatmap (Phase 1)
    map.addLayer({
      id: "labor-heat",
      type: "heatmap",
      source: "warehouses",
      maxzoom: 13,
      paint: {
        "heatmap-weight": ["interpolate", ["linear"], ["get","labor_index"], 0, 0, 1, 1],
        "heatmap-intensity": ["interpolate", ["linear"], ["zoom"], 8, 0.7, 13, 1.3],
        "heatmap-radius": ["interpolate", ["linear"], ["zoom"], 8, 18, 13, 40],
        "heatmap-opacity": 0.35
      }
    });

    // --- Cluster circles
    map.addLayer({
      id: "clusters",
      type: "circle",
      source: "warehouses",
      filter: ["has","point_count"],
      paint: {
        "circle-color": [
          "step",
          ["get","point_count"],
          "#00ffea", 100,
          "#ff7cff", 300,
          "#ffd000"
        ],
        "circle-radius": [
          "step",
          ["get","point_count"],
          18, 100,
          26, 300,
          34
        ],
        "circle-opacity": 0.85
      }
    });

    // Cluster count label
    map.addLayer({
      id: "cluster-count",
      type: "symbol",
      source: "warehouses",
      filter: ["has","point_count"],
      layout: {
        "text-field": ["get","point_count_abbreviated"],
        "text-size": 12
      },
      paint: { "text-color": "#000000" }
    });

    // --- Unclustered points (status-colored)
    map.addLayer({
      id: "unclustered-points",
      type: "circle",
      source: "warehouses",
      filter: ["!", ["has","point_count"]],
      paint: {
        "circle-color": [
          "case",
          ["==", ["get","verified"], 1], "#ffd000",
          ["==", ["get","inspected"], 1], "#ff7cff",
          "#00ffea"
        ],
        "circle-radius": 7,
        "circle-stroke-color": "#000",
        "circle-stroke-width": 1.5,
        "circle-opacity": 0.95
      }
    });

    // Click behavior: clusters zoom in
    map.on("click", "clusters", (e) => {
      const features = map.queryRenderedFeatures(e.point, { layers: ["clusters"] });
      const clusterId = features[0].properties.cluster_id;
      map.getSource("warehouses").getClusterExpansionZoom(clusterId, (err, zoom) => {
        if (err) return;
        map.easeTo({ center: features[0].geometry.coordinates, zoom });
      });
    });

    // Click behavior: point popup
    map.on("click", "unclustered-points", (e) => {
      const f = e.features[0];
      const p = f.properties;

      // Mapbox returns properties as strings sometimes:
      const props = {
        id: p.id,
        name: p.name,
        source: p.source,
        verified: Number(p.verified || 0),
        inspected: Number(p.inspected || 0),
        utilization: (p.utilization === null || p.utilization === "null" || p.utilization === undefined) ? null : Number(p.utilization),
        grade: (p.grade === "null" ? null : p.grade),
        labor_index: Number(p.labor_index || 0)
      };

      new mapboxgl.Popup({ maxWidth: "360px" })
        .setLngLat(f.geometry.coordinates)
        .setHTML(popupHTML(props))
        .addTo(map);
    });

    // Cursor changes
    map.on("mouseenter", "clusters", () => map.getCanvas().style.cursor = "pointer");
    map.on("mouseleave", "clusters", () => map.getCanvas().style.cursor = "");
    map.on("mouseenter", "unclustered-points", () => map.getCanvas().style.cursor = "pointer");
    map.on("mouseleave", "unclustered-points", () => map.getCanvas().style.cursor = "");

    // Initial visibility based on toggles
    setLayerVisibility("submarket-fill", ui.submarkets.checked);
    setLayerVisibility("submarket-outline", ui.submarkets.checked);
    setLayerVisibility("submarket-label", ui.submarkets.checked);
    setLayerVisibility("labor-heat", ui.heatmap.checked);

    applyFilters();
  });

  // =========================
  // UI EVENTS
  // =========================
  ui.submarkets.addEventListener("change", () => {
    setLayerVisibility("submarket-fill", ui.submarkets.checked);
    setLayerVisibility("submarket-outline", ui.submarkets.checked);
    setLayerVisibility("submarket-label", ui.submarkets.checked);
  });

  ui.heatmap.addEventListener("change", () => {
    setLayerVisibility("labor-heat", ui.heatmap.checked);
  });

  ui.verified.addEventListener("change", applyFilters);
  ui.capacity.addEventListener("change", applyFilters);

  ui.btnATL.addEventListener("click", () => {
    map.flyTo({ center: ATL_CENTER, zoom: ATL_ZOOM });
  });

  ui.btnFit.addEventListener("click", () => {
    // Fit to the rough submarkets bounds (works even before warehouses load)
    const bounds = new mapboxgl.LngLatBounds();
    submarketsGeoJSON.features.forEach(f => {
      f.geometry.coordinates[0].forEach(coord => bounds.extend(coord));
    });
    map.fitBounds(bounds, { padding: 60, duration: 900 });
  });
</script>

</body>
</html>